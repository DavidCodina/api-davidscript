name: Build & Deploy
on:
  # https://docs.github.com/en/actions/using-workflows
  # https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows
  # https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request

  #--------------------------------------------------------------------------
  #
  # Note:
  #
  # https://www.udemy.com/course/github-actions-the-complete-guide/learn/lecture/34138630#overview
  # Pull Request from contributors that forked will not occur automatically, but instead require approval.
  # Why? Because obviously you don't want to automatically deploy from forked users.
  # By default, pull requests based on forks do not trigger workflows.
  # First-time contributors must be approved manually. Subsequent PRs will be triggered
  # automatically. That said, if you add a collaborator and they do a first PR, it will
  # trigger automatially on the first time.
  #
  #--------------------------------------------------------------------------
  pull_request:
    # https://github.com/orgs/community/discussions/26724
    # See here if you want to do it when the PR merge occurs, rather than when the PR is closed.
    # For now, I think it makes more sense to do it when the PR is closed.
    # Why? Because a PR is automatically closed when it is merged.
    #! [closed] may not actually be the correct solution. Why? What happens if you
    #! create a PR, and then close it without merging it. Presumably, that would trigger
    #! the deployment, which would be VERY BAD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    types: [closed]

    branches:
      - main
      - master
  workflow_dispatch:
jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18.x]
    steps:
      # This makes the code we've pushed to the branch available for our workflow.
      # Basically, it loads the contents of the branch into the current environment.
      # https://github.com/actions/checkout
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}

      # - name: Cache Dependencies
      #   uses: actions/cache@v3
      #   with:
      #     path: ~/.npm
      #     key: node_modules-${{ hashFiles('**/package-lock.json') }}
      - name: Install Dependencies
        run: npm ci
      - name: Build Project
        run: npm run build
      #` Here it probably makes more sense to include certain files rather than exclude.
      #` That way we will not have to worry about the accidental addition of other files in the future.
      - name: Generate deployment package
        run: zip -r deploy.zip . -x './src/*' './node_modules/*' '*.git*' 'tsconfig.json'

      # https://www.udemy.com/course/github-actions-the-complete-guide/learn/lecture/34139932#overview
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: deploy-folder
          path: deploy.zip
      - name: List Contents Of Directory
        run: ls

  ## Beanstalk Deploy
  ## https://github.com/marketplace/actions/beanstalk-deploy
  deploy:
    #--------------------------------------------------------------------------
    #
    # By default, jobs run in parallel, while steps run sequentially.
    # Thus you really don't want the deploy job to run as a
    # parallel job to the testing job. You could fix this by making
    # the deploy a step. Conversely, you could use the 'needs' keyword.
    #
    # Here I only truly need build, but also dont' want this
    # to deploy unless lint and test are successful.
    #
    #--------------------------------------------------------------------------
    needs: [build]
    name: Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Get deploy.zip
        uses: actions/download-artifact@v3
        with:
          name: deploy-folder
      - name: Verify deploy.zip is in directory now.
        run: ls

      #` At this point, we have the deploy.zip, which includes dist, package.json and package-lock.json
      #` This should be sufficient to upload to Elastic Beanstalk without the 01_build.config
      #` This is based on the assumption that elastic beanstalk will automatically install the packages
      #` and run the start script.
      - name: Output Run ID
        run: echo ${{ github.run_id }}
      - name: Deploy to ELastic Beanstalk
        uses: einaregilsson/beanstalk-deploy@v21
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: api-davidscript
          environment_name: api-davidscript-dev
          ## https://stackoverflow.com/questions/54310050/how-to-version-build-artifacts-using-github-actions
          version_label: '${{ github.run_id }}'
          region: us-east-1
          deployment_package: deploy.zip

  # - name: Deploy to AWS Beanstalk
  #   uses: actions/download-artifact@v3
  #   with:
  #     name: dist # Corresponds to the upload name
  # - name: Verify dist artifact contents
  #   run: ls

  # # bonus:
  # #   needs: deploy
  # #   name: Bonus
  # #   runs-on: ubuntu-latest
  # #   steps:
  # #     # https://docs.github.com/en/actions/learn-github-actions/contexts
  # #     - name: Bonus -  output context of github
  # #       run: echo "${{ toJSON(github) }}"
